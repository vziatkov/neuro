<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Neuro Project - Clustering Demo / –î–µ–º–æ –∫–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏–∏</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      background: #0a0a0a;
      color: #e0e0e0;
      padding: 20px;
      line-height: 1.6;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
    }
    
    h1 {
      color: #4fd1c5;
      margin-bottom: 10px;
    }
    
    .section {
      background: #1a1a1a;
      border: 1px solid #2a2a2a;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 20px;
    }
    
    .section h2 {
      color: #f6ad55;
      margin-bottom: 15px;
      font-size: 1.2em;
    }
    
    button {
      background: #4fd1c5;
      color: #0a0a0a;
      border: none;
      padding: 10px 20px;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 600;
      margin: 5px;
      transition: background 0.2s;
    }
    
    button:hover {
      background: #38b2ac;
    }
    
    .output {
      background: #0f0f0f;
      border: 1px solid #2a2a2a;
      border-radius: 6px;
      padding: 15px;
      margin-top: 10px;
      font-family: 'Monaco', 'Courier New', monospace;
      font-size: 12px;
      max-height: 400px;
      overflow-y: auto;
      white-space: pre-wrap;
    }
    
    .cluster {
      background: #1a2a1a;
      border-left: 3px solid #4fd1c5;
      padding: 10px;
      margin: 10px 0;
      border-radius: 4px;
    }
    
    .cluster h3 {
      color: #4fd1c5;
      margin-bottom: 5px;
    }
    
    .outlier {
      background: #2a1a1a;
      border-left: 3px solid #f6ad55;
      padding: 10px;
      margin: 10px 0;
      border-radius: 4px;
    }
    
    .metrics {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 10px;
      margin-top: 10px;
    }
    
    .metric {
      background: #1a1a2a;
      padding: 10px;
      border-radius: 4px;
      text-align: center;
    }
    
    .metric-value {
      font-size: 1.5em;
      color: #4fd1c5;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üß† Neuro Project - Clustering & Swarm Demo / –î–µ–º–æ –∫–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏–∏ –∏ —Ä–æ—è</h1>
    <p style="margin-bottom: 20px; opacity: 0.8;">
      Interactive demo of clustering, swarm impulses, and emotional core modules.
      <br>
      –ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–∞—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è –º–æ–¥—É–ª–µ–π –∫–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏–∏, –∏–º–ø—É–ª—å—Å–æ–≤ —Ä–æ—è –∏ —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–≥–æ —è–¥—Ä–∞.
    </p>
    
    <div class="section">
      <h2>1. Swarm Impulses / –ò–º–ø—É–ª—å—Å—ã —Ä–æ—è</h2>
      <p style="margin-bottom: 10px; opacity: 0.7; font-size: 0.9em;">
        Test trust-weighted impulse propagation through the swarm network.
        <br>
        –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω–µ–Ω–∏—è –∏–º–ø—É–ª—å—Å–æ–≤ —á–µ—Ä–µ–∑ —Å–µ—Ç—å —Ä–æ—è —Å —É—á—ë—Ç–æ–º –≤–µ—Å–æ–≤ –¥–æ–≤–µ—Ä–∏—è.
      </p>
      <button onclick="testSwarmImpulse()">–ó–∞–ø—É—Å—Ç–∏—Ç—å FOOD_DETECTED / Trigger FOOD_DETECTED</button>
      <button onclick="testDangerImpulse()">–ó–∞–ø—É—Å—Ç–∏—Ç—å DANGER_NEAR / Trigger DANGER_NEAR</button>
      <div id="swarm-output" class="output"></div>
    </div>
    
    <div class="section">
      <h2>2. Emotional Core / –≠–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–µ —è–¥—Ä–æ</h2>
      <p style="margin-bottom: 10px; opacity: 0.7; font-size: 0.9em;">
        View emotional logs generated by swarm impulses and system events.
        <br>
        –ü—Ä–æ—Å–º–æ—Ç—Ä —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã—Ö –ª–æ–≥–æ–≤, —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –∏–º–ø—É–ª—å—Å–∞–º–∏ —Ä–æ—è –∏ —Å–∏—Å—Ç–µ–º–Ω—ã–º–∏ —Å–æ–±—ã—Ç–∏—è–º–∏.
      </p>
      <button onclick="showEmotionalBuffer()">–ü–æ–∫–∞–∑–∞—Ç—å –±—É—Ñ–µ—Ä / Show Buffer</button>
      <button onclick="clearEmotionalBuffer()">–û—á–∏—Å—Ç–∏—Ç—å / Clear</button>
      <div id="emotional-output" class="output"></div>
    </div>
    
    <div class="section">
      <h2>3. Clustering / –ö–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏—è</h2>
      <p style="margin-bottom: 10px; opacity: 0.7; font-size: 0.9em;">
        Test cosine distance-based clustering on different data types.
        <br>
        –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ –∫–æ—Å–∏–Ω—É—Å–Ω–æ–≥–æ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è –¥–ª—è —Ä–∞–∑–ª–∏—á–Ω—ã—Ö —Ç–∏–ø–æ–≤ –¥–∞–Ω–Ω—ã—Ö.
      </p>
      <button onclick="testBiometricClustering()">–ë–∏–æ–º–µ—Ç—Ä–∏—è / Biometrics</button>
      <button onclick="testEmotionalClustering()">–≠–º–æ—Ü–∏–∏ / Emotions</button>
      <button onclick="testGameBehaviorClustering()">–ò–≥—Ä–æ–≤–æ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ / Game Behavior</button>
      <div id="clustering-output" class="output"></div>
    </div>
    
    <div class="section">
      <h2>4. Atlas Waves / –í–æ–ª–Ω—ã –ê—Ç–ª–∞—Å–∞</h2>
      <p style="margin-bottom: 10px; opacity: 0.7; font-size: 0.9em;">
        Real-time visualization of impulse waves propagating through the swarm.
        <br>
        –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏ –≤–æ–ª–Ω –∏–º–ø—É–ª—å—Å–æ–≤, —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω—è—é—â–∏—Ö—Å—è –ø–æ —Ä–æ—é.
      </p>
      <div id="atlas-waves" class="output"></div>
    </div>
  </div>

  <script type="module">
    // –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –º–æ–¥—É–ª–∏ (–≤ —Ä–µ–∞–ª—å–Ω–æ–º –ø—Ä–æ–µ–∫—Ç–µ —á–µ—Ä–µ–∑ Vite)
    // –î–ª—è –¥–µ–º–æ –∏—Å–ø–æ–ª—å–∑—É–µ–º —É–ø—Ä–æ—â—ë–Ω–Ω—ã–µ –≤–µ—Ä—Å–∏–∏
    
    // Mock implementations –¥–ª—è –¥–µ–º–æ
    const emotionalBuffer = [];
    
    function logEmotion(entry) {
      emotionalBuffer.push(entry);
      console.log('[emotional-core]', entry.source, entry.emotion, `strength=${entry.strength.toFixed(2)}`, entry.meta);
    }
    
    function getEmotionalBuffer() {
      return [...emotionalBuffer];
    }
    
    function resetEmotionalBuffer() {
      emotionalBuffer.length = 0;
    }
    
    // Swarm Impulse simulation
    const atlasListeners = [];
    
    function onAtlasWave(listener) {
      atlasListeners.push(listener);
    }
    
    function emitAtlasWave(payload) {
      atlasListeners.forEach(listener => listener(payload));
    }
    
    // Trust graph
    const TRUST_GRAPH = {
      scout: { id: "scout", edges: [{ target: "explorer", weight: 0.92 }] },
      explorer: { id: "explorer", edges: [{ target: "wise", weight: 0.87 }] },
      wise: { id: "wise", edges: [{ target: "guardian", weight: 0.65 }] },
      guardian: { id: "guardian", edges: [] },
      coward: { id: "coward", edges: [{ target: "wise", weight: 0.5 }] },
    };
    
    function triggerFoodImpulse(strength = 1.0) {
      const impulse = { type: "FOOD_DETECTED", strength, origin: "scout", trace: [] };
      propagateImpulse("scout", impulse, new Set());
    }
    
    function triggerDangerImpulse(data) {
      const impulse = { type: "DANGER_NEAR", strength: data.strength, origin: "coward", trace: [] };
      propagateImpulse("coward", impulse, new Set());
    }
    
    function propagateImpulse(nodeId, impulse, visited) {
      if (visited.has(nodeId) || impulse.strength <= 0.01) return;
      visited.add(nodeId);
      
      const node = TRUST_GRAPH[nodeId];
      if (!node) return;
      
      impulse.trace.push(nodeId);
      
      logEmotion({
        timestamp: Date.now(),
        source: nodeId,
        emotion: impulse.type === "FOOD_DETECTED" ? "anticipation" : "panic",
        strength: impulse.strength,
        meta: { impulse: impulse.type, trace: [...impulse.trace] }
      });
      
      emitAtlasWave({
        node: nodeId,
        color: "#FF3B30",
        amplitude: impulse.strength,
        comment: `${impulse.type} ripple`,
        tremor: impulse.type === "DANGER_NEAR" ? 0.3 : 0
      });
      
      node.edges.forEach(edge => {
        const weightedStrength = impulse.strength * Math.max(0, Math.min(1, edge.weight));
        if (weightedStrength > 0.01) {
          propagateImpulse(edge.target, { ...impulse, strength: weightedStrength }, visited);
        }
      });
    }
    
    // Clustering simulation
    function cosineDistance(a, b) {
      let dot = 0, normA = 0, normB = 0;
      for (let i = 0; i < a.length; i++) {
        dot += a[i] * b[i];
        normA += a[i] * a[i];
        normB += b[i] * b[i];
      }
      return 1 - (dot / (Math.sqrt(normA) * Math.sqrt(normB)));
    }
    
    function simpleCluster(embeddings, threshold = 0.3) {
      const clusters = [];
      const processed = new Set();
      
      for (let i = 0; i < embeddings.length; i++) {
        if (processed.has(i)) continue;
        
        const cluster = [i];
        for (let j = i + 1; j < embeddings.length; j++) {
          if (processed.has(j)) continue;
          const dist = cosineDistance(embeddings[i].vector, embeddings[j].vector);
          if (dist < threshold) {
            cluster.push(j);
            processed.add(j);
          }
        }
        
        if (cluster.length >= 2) {
          clusters.push(cluster.map(idx => embeddings[idx]));
          cluster.forEach(idx => processed.add(idx));
        }
      }
      
      const outliers = embeddings.filter((_, idx) => !processed.has(idx));
      return { clusters, outliers };
    }
    
    // Atlas wave visualization
    onAtlasWave((wave) => {
      const wavesDiv = document.getElementById('atlas-waves');
      const waveEl = document.createElement('div');
      waveEl.style.cssText = `
        background: ${wave.color}20;
        border-left: 3px solid ${wave.color};
        padding: 8px;
        margin: 5px 0;
        border-radius: 4px;
        animation: pulse 0.5s;
      `;
      waveEl.innerHTML = `
        <strong>${wave.node}</strong>: ${wave.comment} 
        (amplitude: ${wave.amplitude.toFixed(2)}${wave.tremor ? `, tremor: ${wave.tremor}` : ''})
      `;
      wavesDiv.appendChild(waveEl);
      setTimeout(() => waveEl.remove(), 3000);
    });
    
    // Global functions for buttons
    window.testSwarmImpulse = () => {
      document.getElementById('swarm-output').textContent = '–ó–∞–ø—É—Å–∫ FOOD_DETECTED –∏–º–ø—É–ª—å—Å–∞... / Triggering FOOD_DETECTED impulse...\n';
      resetEmotionalBuffer();
      triggerFoodImpulse(1.0);
      setTimeout(() => {
        const buffer = getEmotionalBuffer();
        document.getElementById('swarm-output').textContent = 
          `–ò–º–ø—É–ª—å—Å —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω–∏–ª—Å—è —á–µ—Ä–µ–∑ ${buffer.length} —É–∑–ª–æ–≤ / Impulse propagated through ${buffer.length} nodes:\n\n` +
          buffer.map(e => 
            `[${e.source}] ${e.emotion} (strength: ${e.strength.toFixed(2)}) ‚Üí trace: ${e.meta.trace.join(' ‚Üí ')}`
          ).join('\n');
      }, 100);
    };
    
    window.testDangerImpulse = () => {
      document.getElementById('swarm-output').textContent = '–ó–∞–ø—É—Å–∫ DANGER_NEAR –∏–º–ø—É–ª—å—Å–∞... / Triggering DANGER_NEAR impulse...\n';
      resetEmotionalBuffer();
      triggerDangerImpulse({ strength: 0.8, biometric: { bpm: 130, stress: 0.9 } });
      setTimeout(() => {
        const buffer = getEmotionalBuffer();
        document.getElementById('swarm-output').textContent = 
          `DANGER –∏–º–ø—É–ª—å—Å —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω–∏–ª—Å—è / DANGER impulse propagated:\n\n` +
          buffer.map(e => 
            `[${e.source}] ${e.emotion} (strength: ${e.strength.toFixed(2)}) ‚Üí ${e.meta.trace.join(' ‚Üí ')}`
          ).join('\n');
      }, 100);
    };
    
    window.showEmotionalBuffer = () => {
      const buffer = getEmotionalBuffer();
      document.getElementById('emotional-output').textContent = 
        buffer.length > 0 
          ? buffer.map(e => 
              `[${new Date(e.timestamp).toLocaleTimeString()}] ${e.source}: ${e.emotion} (${e.strength.toFixed(2)})`
            ).join('\n')
          : '–ë—É—Ñ–µ—Ä –ø—É—Å—Ç. –ó–∞–ø—É—Å—Ç–∏—Ç–µ –∏–º–ø—É–ª—å—Å—ã –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã—Ö –ª–æ–≥–æ–≤.\nBuffer is empty. Trigger impulses to generate emotional logs.';
    };
    
    window.clearEmotionalBuffer = () => {
      resetEmotionalBuffer();
      document.getElementById('emotional-output').textContent = '–ë—É—Ñ–µ—Ä –æ—á–∏—â–µ–Ω. / Buffer cleared.';
    };
    
    window.testBiometricClustering = () => {
      const biometricData = Array.from({ length: 20 }, (_, i) => ({
        id: `bio_${i}`,
        vector: [
          Math.random() * 0.5 + 0.3, // heart rate mean
          Math.random() * 0.2, // heart rate std
          (Math.random() - 0.5) * 0.3, // trend
          Math.random() * 0.4 + 0.4, // breath
          Math.random() * 0.6, // stress
        ],
        metadata: { type: 'biometric' }
      }));
      
      const result = simpleCluster(biometricData, 0.4);
      displayClusteringResult(result, '–ë–∏–æ–º–µ—Ç—Ä–∏—á–µ—Å–∫–∏–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã / Biometric Patterns');
    };
    
    window.testEmotionalClustering = () => {
      const emotions = ['anticipation', 'trust', 'focus', 'panic', 'calm'];
      const emotionalData = Array.from({ length: 15 }, (_, i) => ({
        id: `emo_${i}`,
        vector: [
          Math.random(), // strength
          emotions.indexOf(emotions[Math.floor(Math.random() * emotions.length)]) * 0.1, // emotion encoding
          Math.random() * 10, // time
        ],
        metadata: { type: 'emotional' }
      }));
      
      const result = simpleCluster(emotionalData, 0.5);
      displayClusteringResult(result, '–≠–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã / Emotional Patterns');
    };
    
    window.testGameBehaviorClustering = () => {
      const gameData = Array.from({ length: 25 }, (_, i) => ({
        id: `game_${i}`,
        vector: [
          Math.random(), // difficulty
          Math.random(), // success rate
          Math.random() * 5, // avg time
          Math.random() * 10, // clicks
          Math.random() * 5, // drags
          Math.random() * 2, // pauses
          Math.random() * 100, // completion time
        ],
        metadata: { type: 'game_session' }
      }));
      
      const result = simpleCluster(gameData, 0.35);
      displayClusteringResult(result, '–ò–≥—Ä–æ–≤–æ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ / Game Behavior');
    };
    
    function displayClusteringResult(result, title) {
      const output = document.getElementById('clustering-output');
      let html = `<h3 style="color: #4fd1c5; margin-bottom: 10px;">${title}</h3>`;
      html += `<div class="metrics">
        <div class="metric">
          <div class="metric-value">${result.clusters.length}</div>
          <div>–ö–ª–∞—Å—Ç–µ—Ä–æ–≤ / Clusters</div>
        </div>
        <div class="metric">
          <div class="metric-value">${result.outliers.length}</div>
          <div>–ê–Ω–æ–º–∞–ª–∏–π / Outliers</div>
        </div>
        <div class="metric">
          <div class="metric-value">${result.clusters.reduce((sum, c) => sum + c.length, 0) + result.outliers.length}</div>
          <div>–í—Å–µ–≥–æ —Ç–æ—á–µ–∫ / Total Points</div>
        </div>
      </div>`;
      
      result.clusters.forEach((cluster, idx) => {
        html += `<div class="cluster">
          <h3>–ö–ª–∞—Å—Ç–µ—Ä ${idx + 1} / Cluster ${idx + 1} (${cluster.length} —ç–ª–µ–º–µ–Ω—Ç–æ–≤ / elements)</h3>
          <div>–ß–ª–µ–Ω—ã / Members: ${cluster.map(c => c.id).join(', ')}</div>
        </div>`;
      });
      
      if (result.outliers.length > 0) {
        html += `<div class="outlier">
          <h3>–ê–Ω–æ–º–∞–ª–∏–∏ / Outliers (${result.outliers.length})</h3>
          <div>${result.outliers.map(o => o.id).join(', ')}</div>
        </div>`;
      }
      
      output.innerHTML = html;
    }
  </script>
</body>
</html>

