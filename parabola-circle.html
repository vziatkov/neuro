<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Parabola & Circle — Tangent Geometry</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #050508;
            color: #e5e5e5;
            font-family: 'JetBrains Mono', monospace;
            overflow: hidden;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        canvas { display: block; cursor: crosshair; }
        .header {
            position: fixed; top: 24px; left: 28px; z-index: 10; pointer-events: none;
        }
        .header h1 { font-size: 14px; font-weight: 600; letter-spacing: 2px; color: rgba(255,255,255,0.7); text-transform: uppercase; }
        .header .sub { font-size: 10px; color: rgba(255,255,255,0.25); margin-top: 4px; }
        .formula {
            position: fixed; bottom: 28px; left: 28px; z-index: 10; pointer-events: none;
        }
        .formula .line { font-size: 11px; color: rgba(255,255,255,0.35); line-height: 1.8; }
        .formula .result { font-size: 14px; font-weight: 600; color: #ee6644; margin-top: 8px; }
        .legend {
            position: fixed; top: 28px; right: 28px; z-index: 10;
            display: flex; flex-direction: column; gap: 6px; pointer-events: none;
        }
        .legend-item { display: flex; align-items: center; gap: 8px; font-size: 10px; color: rgba(255,255,255,0.35); }
        .legend-dot { width: 12px; height: 3px; border-radius: 1px; flex-shrink: 0; }
        .toggle {
            position: fixed; bottom: 80px; left: 50%; transform: translateX(-50%);
            z-index: 10; display: flex; gap: 2px;
            background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1);
            border-radius: 6px; padding: 3px;
        }
        .toggle-btn {
            background: none; border: none; color: rgba(255,255,255,0.35);
            font-family: 'JetBrains Mono', monospace; font-size: 11px; font-weight: 500;
            padding: 6px 16px; border-radius: 4px; cursor: pointer; transition: all 0.25s;
        }
        .toggle-btn:hover { color: rgba(255,255,255,0.6); }
        .toggle-btn.active {
            background: rgba(238,68,68,0.15); color: #ee6644; border: 1px solid rgba(238,68,68,0.3);
        }
        .toggle-hint {
            position: fixed; bottom: 60px; left: 50%; transform: translateX(-50%);
            z-index: 10; font-size: 9px; color: rgba(255,255,255,0.15);
            letter-spacing: 0.5px; font-style: italic; pointer-events: none;
        }
        .back {
            position: fixed; bottom: 28px; right: 28px; z-index: 10;
            font-size: 10px; color: rgba(255,255,255,0.2); text-decoration: none; transition: color 0.2s;
        }
        .back:hover { color: rgba(255,95,31,0.8); }
    </style>
</head>
<body>
    <canvas id="c"></canvas>

    <div class="header">
        <h1>Parabola & Circle</h1>
        <div class="sub">Circle tangent to x=0, y=L, and y=x²/L — Newton's method on a quintic</div>
    </div>

    <div class="legend">
        <div class="legend-item"><div class="legend-dot" style="background:#e8e8e8"></div>Unit square</div>
        <div class="legend-item"><div class="legend-dot" style="background:#e8e8e8"></div>Parabola y = x²</div>
        <div class="legend-item"><div class="legend-dot" style="background:#ee4444"></div>Inscribed circle</div>
        <div class="legend-item"><div class="legend-dot" style="background:#44cc66"></div>Tangent point & radius</div>
        <div class="legend-item"><div class="legend-dot" style="background:#4488ff;opacity:.5"></div>Construction lines</div>
    </div>

    <div class="formula">
        <div class="line">f(u) = 8u⁵ + u⁴ − 6u³ + 2u² − 2u + 1 = 0</div>
        <div class="line">r = t(L² − 2t²) / L(2t − L)</div>
        <div class="line">C = (r, L − r)</div>
        <div class="result" id="result"></div>
    </div>

    <div class="toggle" id="toggle">
        <button class="toggle-btn active" data-mode="inscribed">Inscribed</button>
        <button class="toggle-btn" data-mode="mirror">Mirror</button>
        <button class="toggle-btn" data-mode="outer">Outer</button>
    </div>
    <div class="toggle-hint" id="toggle-hint">Same law — different frame — different form</div>

    <a href="/neuro/" class="back">← Neuro</a>

    <script>
    (function() {
        const canvas = document.getElementById('c');
        const ctx = canvas.getContext('2d');
        const dpr = Math.min(window.devicePixelRatio, 2);

        const L = 1;

        // f(u) = 8u^5 + u^4 - 6u^3 + 2u^2 - 2u + 1
        function f(u) { return 8*u**5 + u**4 - 6*u**3 + 2*u**2 - 2*u + 1; }

        // Bisection in a given range with bracket scan
        function solveU_range(a0, b0) {
            let a = a0, b = b0;
            let fa = f(a), fb = f(b);
            if (fa * fb > 0) {
                const N = 4000;
                let prevU = a, prevF = fa;
                for (let i = 1; i <= N; i++) {
                    const uu = a0 + (b0 - a0) * (i / N);
                    const fu = f(uu);
                    if (prevF * fu <= 0) { a = prevU; fa = prevF; b = uu; fb = fu; break; }
                    prevU = uu; prevF = fu;
                }
                if (fa * fb > 0) return null;
            }
            for (let i = 0; i < 200; i++) {
                const m = (a + b) / 2;
                const fm = f(m);
                if (Math.abs(fm) < 1e-15) return m;
                if (fa * fm <= 0) { b = m; fb = fm; } else { a = m; fa = fm; }
            }
            return (a + b) / 2;
        }

        function getGeometry(u) {
            const t = u * L;
            const denom = L * (2 * t - L);
            const r = (t * (L * L - 2 * t * t)) / denom;
            return { u, t, r, Cx: r, Cy: L - r, Px: t, Py: (t * t) / L };
        }

        // Two solutions from the SAME quintic:
        // Inscribed (u ≈ 0.6466, in range 0.6–0.8) — circle fits inside square
        // Outer tangent (u ≈ 0.55, in range 0.5–0.6) — circle escapes the square
        const uInscribed = solveU_range(0.6, 0.8);
        const uOuter = solveU_range(0.5 + 1e-6, 0.6);

        console.log('Inscribed u:', uInscribed, '→ r:', uInscribed ? getGeometry(uInscribed).r : null);
        console.log('Outer u:', uOuter, '→ r:', uOuter ? getGeometry(uOuter).r : null);

        // Mirror: reflect across diagonal y=x → swap Cx↔Cy, Px↔Py
        function mirrorGeo(g) {
            return { u: g.u, t: g.t, r: g.r, Cx: g.Cy, Cy: g.Cx, Px: g.Py, Py: g.Px, mirrored: true };
        }

        const inscribedGeo = uInscribed ? getGeometry(uInscribed) : getGeometry(0.6466);
        const solutions = {
            inscribed: inscribedGeo,
            mirror: mirrorGeo(inscribedGeo),
            outer: uOuter ? getGeometry(uOuter) : getGeometry(0.5510)
        };

        let currentMode = 'inscribed';
        let geo = solutions.inscribed;
        let transitionProgress = 1;
        let targetGeo = geo;
        let fromGeo = geo;

        function updateResult() {
            document.getElementById('result').textContent =
                `u ≈ ${geo.u.toFixed(6)}  ·  r ≈ ${geo.r.toFixed(6)}`;
        }
        updateResult();

        // Toggle logic
        document.getElementById('toggle').addEventListener('click', (e) => {
            const btn = e.target.closest('.toggle-btn');
            if (!btn) return;
            const mode = btn.dataset.mode;
            if (mode === currentMode) return;
            if (mode === 'outer' && !solutions.outer) return;

            currentMode = mode;
            fromGeo = { ...geo };
            targetGeo = solutions[mode];
            transitionProgress = 0;

            document.querySelectorAll('.toggle-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
        });

        let sz, ox, oy, scale;
        let animT = 0;
        let buildProgress = 0;

        let viewScale = 1;

        function resize() {
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;
            canvas.style.width = window.innerWidth + 'px';
            canvas.style.height = window.innerHeight + 'px';
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            updateView();
        }

        function updateView() {
            const maxR = Math.abs(geo.r);
            viewScale += ((maxR > L * 0.5 ? 0.3 : 1) - viewScale) * 0.04;
            sz = Math.min(window.innerWidth, window.innerHeight) * 0.55 * viewScale;
            ox = window.innerWidth / 2 - sz / 2;
            oy = window.innerHeight / 2 - sz / 2;
            scale = sz;
        }

        // Math coords (origin bottom-left) → screen
        function toS(x, y) {
            return [ox + x * scale, oy + (L - y) * scale];
        }

        function sLine(x1, y1, x2, y2, color, width, dash) {
            const [a, b] = toS(x1, y1);
            const [c, d] = toS(x2, y2);
            ctx.strokeStyle = color; ctx.lineWidth = width;
            ctx.setLineDash(dash || []); ctx.beginPath();
            ctx.moveTo(a, b); ctx.lineTo(c, d); ctx.stroke();
            ctx.setLineDash([]);
        }

        function sCirc(cx, cy, cr, color, width, dash) {
            const [a, b] = toS(cx, cy);
            ctx.strokeStyle = color; ctx.lineWidth = width;
            ctx.setLineDash(dash || []); ctx.beginPath();
            ctx.arc(a, b, cr * scale, 0, Math.PI * 2); ctx.stroke();
            ctx.setLineDash([]);
        }

        function sDot(cx, cy, cr, color) {
            const [a, b] = toS(cx, cy);
            ctx.fillStyle = color; ctx.beginPath();
            ctx.arc(a, b, cr * scale, 0, Math.PI * 2); ctx.fill();
        }

        function sLabel(x, y, text, color, size, dx, dy) {
            const [a, b] = toS(x, y);
            ctx.fillStyle = color;
            ctx.font = `${size || 11}px 'JetBrains Mono', monospace`;
            ctx.fillText(text, a + (dx || 6), b + (dy || -6));
        }

        function easeOut(v) { return 1 - Math.pow(1 - v, 3); }
        function lerp(a, b, t) { return a + (b - a) * t; }

        function draw() {
            // Smooth transition between solutions
            if (transitionProgress < 1) {
                transitionProgress = Math.min(1, transitionProgress + 0.025);
                const et = easeOut(transitionProgress);
                geo = {
                    u: lerp(fromGeo.u, targetGeo.u, et),
                    t: lerp(fromGeo.t, targetGeo.t, et),
                    r: lerp(fromGeo.r, targetGeo.r, et),
                    Cx: lerp(fromGeo.Cx, targetGeo.Cx, et),
                    Cy: lerp(fromGeo.Cy, targetGeo.Cy, et),
                    Px: lerp(fromGeo.Px, targetGeo.Px, et),
                    Py: lerp(fromGeo.Py, targetGeo.Py, et),
                    mirrored: targetGeo.mirrored,
                };
                updateResult();
            }
            const w = window.innerWidth, h = window.innerHeight;
            ctx.clearRect(0, 0, w, h);

            const bp = Math.min(buildProgress, 1);
            const s1 = easeOut(Math.min(1, bp * 3.5));
            const s2 = easeOut(Math.max(0, Math.min(1, (bp - 0.2) * 3)));
            const s3 = easeOut(Math.max(0, Math.min(1, (bp - 0.45) * 3)));
            const s4 = easeOut(Math.max(0, Math.min(1, (bp - 0.65) * 2.8)));
            const pulse = 0.5 + 0.5 * Math.sin(animT * 1.5);

            // Step 1: Square
            if (s1 > 0) {
                ctx.globalAlpha = s1;

                // Grid
                for (let g = 0; g <= 1; g += 0.25) {
                    for (let h = 0; h <= 1; h += 0.25) {
                        sDot(g, h, 0.003, 'rgba(255,255,255,0.06)');
                    }
                }

                // Square edges
                sLine(0, 0, L, 0, 'rgba(255,255,255,0.3)', 1);
                sLine(L, 0, L, L, 'rgba(255,255,255,0.3)', 1);
                sLine(L, L, 0, L, 'rgba(255,255,255,0.3)', 1);
                sLine(0, L, 0, 0, 'rgba(255,255,255,0.3)', 1);

                // Corner dots
                [[0,0],[L,0],[L,L],[0,L]].forEach(([px,py]) => {
                    sDot(px, py, 0.005, 'rgba(255,255,255,0.5)');
                });

                sLabel(0.5, L, 'L', 'rgba(255,255,255,0.2)', 10, -3, -10);
                ctx.globalAlpha = 1;
            }

            // Step 2: Parabola y = x²/L + diagonal
            if (s2 > 0) {
                ctx.globalAlpha = s2;

                // Parabola — y=x² or mirrored x=y² (both from origin to (L,L))
                const isMirror = geo.mirrored;
                const [p0x, p0y] = toS(0, 0);
                ctx.strokeStyle = 'rgba(255,255,255,0.7)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(p0x, p0y);
                const steps = 80;
                for (let i = 1; i <= steps; i++) {
                    const param = (i / steps) * L * s2;
                    let px, py;
                    if (isMirror) {
                        py = param; px = (param * param) / L;
                    } else {
                        px = param; py = (param * param) / L;
                    }
                    const [sx, sy] = toS(px, py);
                    ctx.lineTo(sx, sy);
                }
                ctx.stroke();

                if (isMirror) {
                    sLabel(0.2, 0.6, 'x = y²', 'rgba(255,255,255,0.35)', 11, 0, 0);
                } else {
                    sLabel(0.55, 0.25, 'y = x²', 'rgba(255,255,255,0.35)', 11, 0, 8);
                }

                // Diagonal hint (parabola approaches this at x=L)
                ctx.globalAlpha = s2 * 0.15;
                sLine(0, 0, L, L, 'rgba(255,255,255,0.3)', 1, [4, 4]);
                ctx.globalAlpha = 1;
            }

            // Step 3: Construction
            if (s3 > 0) {
                ctx.globalAlpha = s3 * 0.5;

                const isOuter = geo.r > L * 0.5;
                const isMir = geo.mirrored;

                // Tangent lines from center to walls
                if (isMir) {
                    // Mirror: tangent to right side (x=L) and bottom (y=0)
                    sLine(geo.Cx, geo.Cy, L, geo.Cy, 'rgba(68,136,255,0.5)', 1, [4, 4]);
                    sLabel((geo.Cx + L) / 2, geo.Cy, 'r', 'rgba(68,136,255,0.5)', 9, -3, -8);
                    sLine(geo.Cx, geo.Cy, geo.Cx, 0, 'rgba(68,136,255,0.5)', 1, [4, 4]);
                    sLabel(geo.Cx, geo.Cy / 2, 'r', 'rgba(68,136,255,0.5)', 9, 6, 0);
                } else {
                    // Original: tangent to left side (x=0) and top (y=L)
                    if (!isOuter || geo.Cx > 0) {
                        sLine(geo.Cx, geo.Cy, 0, geo.Cy, 'rgba(68,136,255,0.5)', 1, [4, 4]);
                        sLabel(Math.max(0, geo.Cx / 2), geo.Cy, 'r', 'rgba(68,136,255,0.5)', 9, -3, -8);
                    }
                    sLine(geo.Cx, geo.Cy, geo.Cx, L, 'rgba(68,136,255,0.5)', 1, [4, 4]);
                    sLabel(geo.Cx, (geo.Cy + L) / 2, 'r', 'rgba(68,136,255,0.5)', 9, 6, 0);
                }

                // Line from center to contact point
                sLine(geo.Cx, geo.Cy, geo.Px, geo.Py, 'rgba(68,204,102,0.6)', 1, [4, 4]);
                sLabel((geo.Cx + geo.Px) / 2, (geo.Cy + geo.Py) / 2, 'r', 'rgba(68,204,102,0.5)', 9, 6, -6);

                // Contact point
                sDot(geo.Px, geo.Py, 0.006, 'rgba(68,204,102,0.9)');
                sLabel(geo.Px, geo.Py, `P(${geo.Px.toFixed(2)}, ${geo.Py.toFixed(2)})`, 'rgba(68,204,102,0.5)', 9, 8, 10);

                // Tangent line at contact point
                const slope = (2 * geo.Px) / L;
                const tanLen = 0.15;
                const tdx = tanLen / Math.sqrt(1 + slope * slope);
                const tdy = slope * tdx;
                sLine(geo.Px - tdx, geo.Py - tdy, geo.Px + tdx, geo.Py + tdy, 'rgba(68,204,102,0.3)', 1);

                // Center dot
                sDot(geo.Cx, geo.Cy, 0.005, 'rgba(68,136,255,0.7)');
                sLabel(geo.Cx, geo.Cy, 'C', 'rgba(68,136,255,0.5)', 10, -14, -8);

                ctx.globalAlpha = 1;
            }

            // Step 4: The circle
            if (s4 > 0) {
                const cr = Math.abs(geo.r) * s4;
                const ga = 0.15 + pulse * 0.1;
                const isOuter = geo.r > L * 0.5;
                const circColor = isOuter ? '255,140,50' : geo.mirrored ? '68,136,255' : '238,68,68';

                // Glow
                sCirc(geo.Cx, geo.Cy, cr + 0.008, `rgba(${circColor},${ga * s4})`, 6);
                // Main
                sCirc(geo.Cx, geo.Cy, cr, `rgba(${circColor},${0.8 * s4})`, 2);
                // Center
                sDot(geo.Cx, geo.Cy, 0.004, `rgba(${circColor},${s4})`);

                if (s4 > 0.8) {
                    sLabel(geo.Cx, geo.Cy, `r ≈ ${Math.abs(geo.r).toFixed(4)}`, `rgba(${circColor},0.7)`, 10, 10, 5);

                    if (isOuter) {
                        sLabel(geo.Cx, geo.Cy, 'OUTER', `rgba(${circColor},0.4)`, 9, 10, 18);
                    } else if (geo.mirrored) {
                        sLabel(geo.Cx, geo.Cy, 'MIRROR', `rgba(${circColor},0.4)`, 9, 10, 18);
                    }
                }
            }
        }

        function animate() {
            animT += 0.016;
            if (buildProgress < 1.2) buildProgress += 0.005;
            updateView();
            draw();
            requestAnimationFrame(animate);
        }

        window.addEventListener('resize', resize);
        resize();
        animate();
    })();
    </script>
</body>
</html>
