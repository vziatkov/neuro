<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Yin-Yang · Preloader — Breath & Pulse</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #050508;
            color: #e5e5e5;
            font-family: 'JetBrains Mono', monospace;
            overflow: hidden;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #preloader {
            display: block;
            cursor: default;
        }
        .header {
            position: fixed;
            top: 24px;
            left: 28px;
            z-index: 10;
            pointer-events: none;
        }
        .header h1 {
            font-size: 14px;
            font-weight: 600;
            letter-spacing: 2px;
            color: rgba(255,255,255,0.7);
            text-transform: uppercase;
        }
        .header .sub {
            font-size: 10px;
            color: rgba(255,255,255,0.25);
            margin-top: 4px;
        }
        .formula {
            position: fixed;
            bottom: 28px;
            left: 28px;
            z-index: 10;
            pointer-events: none;
        }
        .formula .line {
            font-size: 11px;
            color: rgba(255,255,255,0.35);
            line-height: 1.8;
        }
        .formula .result {
            font-size: 14px;
            font-weight: 600;
            color: #ff8c42;
            margin-top: 8px;
        }
        .legend {
            position: fixed;
            top: 28px;
            right: 28px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 6px;
            pointer-events: none;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 10px;
            color: rgba(255,255,255,0.35);
        }
        .legend-dot { width: 12px; height: 3px; border-radius: 1px; flex-shrink: 0; }
        .back {
            position: fixed;
            bottom: 28px;
            right: 28px;
            z-index: 10;
            font-size: 10px;
            color: rgba(255,255,255,0.2);
            text-decoration: none;
            transition: color 0.2s;
        }
        .back:hover { color: rgba(255,95,31,0.8); }
    </style>
</head>
<body>
    <canvas id="preloader"></canvas>

    <div class="header">
        <h1>Yin-Yang · Preloader</h1>
        <div class="sub">Center accelerates, emits; edges burst. Breath & pulse modulate.</div>
    </div>

    <div class="legend">
        <div class="legend-item"><div class="legend-dot" style="background:#FF5F1F"></div>Central triquetra</div>
        <div class="legend-item"><div class="legend-dot" style="background:rgba(255,255,255,0.6)"></div>Small Yin-Yang</div>
        <div class="legend-item"><div class="legend-dot" style="background:#DC143C"></div>Burst particles</div>
    </div>

    <div class="formula">
        <div class="line">Breath ~0.2 Hz · Heart ~1 Hz</div>
        <div class="line">rotation += a × (1 + 0.25×sin(breath))</div>
        <div class="result">n_circles ∝ speed × (0.85 + 0.3×sin(heart))</div>
    </div>

    <a href="/neuro/" class="back">← Neuro</a>

    <script>
    (function() {
        const smallSvgString = `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="-40 -40 80 80">
                <circle r="39" style="stroke-width:1; stroke:rgba(255,255,255,0.85)"/>
                <path fill="rgba(255,255,255,0.12)" d="M0,38a38,38 0 0 1 0,-76a19,19 0 0 1 0,38a19,19 0 0 0 0,38"/>
                <circle r="5" cy="19" fill="rgba(255,255,255,0.9)"/>
                <circle r="5" cy="-19" fill="#FF5F1F"/>
            </svg>
        `;

        const centralSvgString = `
            <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" height="3122" width="3122">
                <defs>
                    <g id="triya">
                        <path d="M0 0  a780,780 0 0,0 1560,0  a1560,1560 0 0,0 -2340,-1351  A780,780 0 1,1 0,0  "/>
                    </g>
                    <circle id="circ" r="260" cx="780" style="stroke-width:1"/>
                </defs>
                <g transform="translate(1561,1561)">
                    <use style="fill:#FF5F1F; stroke:#FF5F1F; stroke-width:10" xlink:href="#triya"/>
                    <use transform="rotate(120)" style="fill:rgba(255,255,255,0.9); stroke:rgba(255,255,255,0.9); stroke-width:10" xlink:href="#triya"/>
                    <use transform="rotate(240)" style="fill:#2F2F2F; stroke:rgba(255,255,255,0.2); stroke-width:20" xlink:href="#triya"/>
                    <use transform="rotate(120)" style="fill:#2F2F2F; stroke:#2F2F2F;" xlink:href="#circ"/>
                    <use transform="rotate(240)" style="fill:#FF5F1F; stroke:#FF5F1F; stroke-width:1" xlink:href="#circ"/>
                    <use transform="rotate(0)" style="fill:rgba(255,255,255,0.9); stroke:rgba(255,255,255,0.9); stroke-width:1" xlink:href="#circ"/>
                </g>
            </svg>
        `;

        const canvas = document.getElementById('preloader');
        const ctx = canvas.getContext('2d');
        const scaleFactor = 4;
        const centralCircleDiameter = 60;
        const smallCircleDiameter = 25;
        const maxNumCircles = 100;
        const maxAccelerationCentralCircle = 0.6;
        const smallCircleSpeedRotation = 0.2;

        let centerX, centerY;
        let centralImg = null;
        let smallImg = null;
        let centralOffscreen = null;
        let smallOffscreen = null;

        const centralCircle = {
            x: 0, y: 0, speed: 0, alpha: 1, burst: false, particles: [], rotation: 0, direction: { x: 0, y: 0 }
        };

        function loadImage(svgString) {
            return new Promise((resolve) => {
                const img = new Image();
                const blob = new Blob([svgString.trim()], { type: 'image/svg+xml;charset=utf-8' });
                img.onload = () => resolve(img);
                img.src = URL.createObjectURL(blob);
            });
        }

        function createOffscreen(img, size) {
            const c = document.createElement('canvas');
            c.width = size;
            c.height = size;
            const cx = c.getContext('2d');
            cx.imageSmoothingEnabled = true;
            cx.drawImage(img, 0, 0, size, size);
            return c;
        }

        function speedToCountSmallCircles(speed) {
            if (speed < 0.45) return 0;
            return Math.min(maxNumCircles, Math.floor(speed * 50));
        }

        const PARTICLE_COLORS = ['#FF5F1F', '#DC143C', '#2F2F2F', 'rgba(255,255,255,0.6)'];

        function createParticles(circle) {
            const n = 6 + Math.random() * 4;
            for (let i = 0; i < n; i++) {
                const angle = Math.random() * Math.PI * 2;
                const s = 1;
                circle.particles.push({
                    x: circle.x, y: circle.y, radius: 2,
                    speedX: s * Math.cos(angle), speedY: s * Math.sin(angle),
                    alpha: 1, fadeSpeed: 0.02, color: PARTICLE_COLORS[Math.floor(Math.random() * PARTICLE_COLORS.length)]
                });
            }
        }

        function createCircle() {
            const angle = Math.random() * Math.PI * 2;
            return {
                x: centerX, y: centerY, speed: 1 + Math.random() * 2,
                direction: { x: Math.cos(angle), y: Math.sin(angle) },
                alpha: 1, burst: false, particles: [], rotation: 0
            };
        }

        function resize() {
            const w = window.innerWidth;
            const h = window.innerHeight;
            canvas.width = w * scaleFactor;
            canvas.height = h * scaleFactor;
            canvas.style.width = w + 'px';
            canvas.style.height = h + 'px';
            centerX = (canvas.width / scaleFactor) / 2;
            centerY = (canvas.height / scaleFactor) / 2;
            centralCircle.x = centerX;
            centralCircle.y = centerY;
        }

        let circles = [];
        let rotationSpeed = 0.001;
        const centralCircleAcceleration = 0.001;
        let startTime = 0;

        const BREATH_FREQ = 0.2;
        const HEART_FREQ = 1.0;

        function drawCircle(circle, offscreen) {
            if (!ctx || !offscreen) return;
            ctx.save();
            ctx.setTransform(scaleFactor, 0, 0, scaleFactor, 0, 0);
            ctx.globalAlpha = circle.alpha;
            ctx.translate(circle.x, circle.y);
            ctx.rotate(circle.rotation);
            ctx.imageSmoothingEnabled = true;
            ctx.drawImage(offscreen, -offscreen.width / 2, -offscreen.height / 2);
            ctx.restore();
        }

        function drawParticle(p) {
            if (!ctx) return;
            ctx.save();
            ctx.setTransform(scaleFactor, 0, 0, scaleFactor, 0, 0);
            ctx.globalAlpha = p.alpha;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
            ctx.fillStyle = p.color;
            ctx.fill();
            ctx.restore();
        }

        function animate(t) {
            if (!startTime) startTime = t;
            const sec = (t - startTime) / 1000;
            const breathPhase = sec * Math.PI * 2 * BREATH_FREQ;
            const heartPhase = sec * Math.PI * 2 * HEART_FREQ;

            const w = canvas.width / scaleFactor;
            const h = canvas.height / scaleFactor;

            if (!ctx) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (!centralOffscreen || !smallOffscreen) {
                requestAnimationFrame(animate);
                return;
            }

            const breathGain = 1 + 0.25 * Math.sin(breathPhase);
            const heartGain = 0.85 + 0.3 * Math.sin(heartPhase);

            circles.forEach((circle, index) => {
                if (!circle.burst) {
                    circle.x += circle.direction.x * circle.speed;
                    circle.y += circle.direction.y * circle.speed;
                    circle.rotation += smallCircleSpeedRotation;
                    drawCircle(circle, smallOffscreen);
                    if (circle.y <= smallCircleDiameter || circle.y + smallCircleDiameter >= h ||
                        circle.x <= smallCircleDiameter || circle.x + smallCircleDiameter >= w) {
                        circle.burst = true;
                        createParticles(circle);
                    }
                } else {
                    circle.particles.forEach((particle, pi) => {
                        particle.x += particle.speedX;
                        particle.y += particle.speedY;
                        particle.alpha -= particle.fadeSpeed * (0.9 + 0.2 * Math.sin(breathPhase));
                        if (particle.alpha <= 0) {
                            circle.particles.splice(pi, 1);
                        } else {
                            drawParticle(particle);
                        }
                    });
                    if (circle.particles.length === 0) {
                        circles[index] = createCircle();
                    }
                }
            });

            if (rotationSpeed < maxAccelerationCentralCircle) {
                rotationSpeed += centralCircleAcceleration * breathGain;
            }
            centralCircle.rotation += rotationSpeed;
            drawCircle(centralCircle, centralOffscreen);

            const baseCount = speedToCountSmallCircles(rotationSpeed);
            const desiredNumCircles = Math.max(0, Math.min(maxNumCircles, Math.floor(baseCount * heartGain)));
            while (circles.length < desiredNumCircles) {
                circles.push(createCircle());
            }

            requestAnimationFrame(animate);
        }

        Promise.all([loadImage(centralSvgString), loadImage(smallSvgString)]).then(([cImg, sImg]) => {
            centralImg = cImg;
            smallImg = sImg;
            centralOffscreen = createOffscreen(centralImg, centralCircleDiameter);
            smallOffscreen = createOffscreen(smallImg, smallCircleDiameter);
            circles = [];
            const n = speedToCountSmallCircles(rotationSpeed);
            for (let i = 0; i < n; i++) circles.push(createCircle());
        });

        window.addEventListener('resize', resize);
        resize();
        requestAnimationFrame(animate);
    })();
    </script>
</body>
</html>
